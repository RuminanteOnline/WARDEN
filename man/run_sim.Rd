% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_sim.R
\name{run_sim}
\alias{run_sim}
\title{Run the simulation}
\usage{
run_sim(
  arm_list = c("int", "noint"),
  sensitivity_inputs = NULL,
  common_all_inputs = NULL,
  common_pt_inputs = NULL,
  unique_pt_inputs = NULL,
  init_event_list = NULL,
  evt_react_list = evt_react_list,
  util_ongoing_list = NULL,
  util_instant_list = NULL,
  util_cycle_list = NULL,
  cost_ongoing_list = NULL,
  cost_instant_list = NULL,
  cost_cycle_list = NULL,
  other_ongoing_list = NULL,
  other_instant_list = NULL,
  npats = 500,
  n_sim = 1,
  psa_bool = NULL,
  sensitivity_bool = FALSE,
  sensitivity_names = NULL,
  n_sensitivity = 1,
  input_out = NULL,
  ipd = 1
)
}
\arguments{
\item{arm_list}{A vector of the names of the interventions evaluated in the simulation}

\item{sensitivity_inputs}{A list of sensitivity inputs that do not change within a sensitivity in a similar fashion to common_all_inputs, etc}

\item{common_all_inputs}{A list of inputs common across patients that do not change within a simulation}

\item{common_pt_inputs}{A list of inputs that change across patients but are not affected by the intervention}

\item{unique_pt_inputs}{A list of inputs that change across each intervention}

\item{init_event_list}{A list of initial events and event times. If no initial events are given, a "Start" event at time 0 is created automatically}

\item{evt_react_list}{A list of event reactions}

\item{util_ongoing_list}{Vector of QALY named variables that are accrued at an ongoing basis (discounted using drq)}

\item{util_instant_list}{Vector of QALY named variables that are accrued instantaneously at an event (discounted using drq)}

\item{util_cycle_list}{Vector of QALY named variables that are accrued in cycles (discounted using drq)}

\item{cost_ongoing_list}{Vector of cost named variables that are accrued at an ongoing basis (discounted using drc)}

\item{cost_instant_list}{Vector of cost named variables that are accrued instantaneously at an event (discounted using drc)}

\item{cost_cycle_list}{Vector of cost named variables that are accrued in cycles (discounted using drc)}

\item{other_ongoing_list}{Vector of other named variables that are accrued at an ongoing basis (discounted using drq)}

\item{other_instant_list}{Vector of other named variables that are accrued instantaneously at an event (discounted using drq)}

\item{npats}{The number of patients to be simulated (it will simulate npats * length(arm_list))}

\item{n_sim}{The number of simulations to run per sensitivity}

\item{psa_bool}{A boolean to determine if PSA should be conducted. If n_sim > 1 and psa_bool = FALSE, the differences between simulations will be due to sampling}

\item{sensitivity_bool}{A boolean to determine if Scenarios/DSA should be conducted.}

\item{sensitivity_names}{A vector of scenario/DSA names that can be used to select the right sensitivity (e.g., c("Scenario_1", "Scenario_2")). The parameter "sens_name_used" is created from it which corresponds to the one being used for each iteration.}

\item{n_sensitivity}{Number of sensitivity analysis (DSA or Scenarios) to run. It will be interacted with sensitivity_names argument if not null (n_sensitivityitivity = n_sensitivity * length(sensitivity_names)). For DSA, it should be as many parameters as there are. For scenario, it should be 1.}

\item{input_out}{A vector of variables to be returned in the output data frame}

\item{ipd}{Integer taking value 1 for full IPD data returned, and 2 IPD data but aggregating events (returning last value for numeric/character/factor variables. For other objects (e.g., matrices), the IPD will still be returned as the aggregation rule is not clear). Other values mean no IPD data returned (removes non-numerical or length>1 items)}
}
\value{
A list of data frames with the simulation results
}
\description{
Run the simulation
}
\details{
This function is slightly different from \code{run_sim_parallel}.
\code{run_sim_parallel} only runs multiple-core at the simulation level.
\code{run_sim} uses only-single core.
\code{run_sim} can be more efficient if using only one simulation (e.g., deterministic),
while \code{run_sim_parallel} will be more efficient if the number of simulations is >1 (e.g., PSA).

Event ties are processed in the order declared within the \code{init_event_list} argument (\code{evts} argument within the first sublist of that object).
To do so, the program automatically adds a sequence from to 0 to the (number of events - 1) times 1e-10 to add to the event times when selecting the event with minimum time.
This time has been selected as it's relatively small yet not so small as to be ignored by which.min (see .Machine for more details)

A list of protected objects that should not be used by the user as input names to avoid the risk of overwriting them is as follows:
c("arm", "arm_list", "categories_for_export", "cur_evtlist", "curtime", "evt", "i", "prevtime", "sens", "simulation", "sens_name_used","list_env","uc_lists","npats","ipd").

The engine uses the L'Ecuyer-CMRG for the random number generator

If no \code{drc} or `drq parameters are passed within any of the input lists, these are assigned value 0.03.

Ongoing items will look backward to the last time updated when performing the discounting and accumulation.
This means that the user does not necessarily need to keep updating the value, but only add it when the value
changes looking forward (e.g., o_q = utility at event 1, at event 2 utility does not change, but at event 3 it does,
so we want to make sure to add o_q = utility at event 3 before updating utility. The program will automatically
look back until event 1)

If the \code{cycle} lists are used, then it is expected the user will declare as well the name of the variable
pasted with \code{cycle_l} and \code{cycle_starttime} (e.g., c_default_cycle_l and c_default_cycle_starttime) to
ensure the discounting can be computed using cycles, with cycle_l being the cycle length, and cycle_starttime
being the starting time in which the variable started counting.
}
\examples{
\dontrun{
run_sim(arm_list=c("int","noint"),
common_all_inputs = common_all_inputs,
common_pt_inputs = common_pt_inputs,
unique_pt_inputs = unique_pt_inputs,
init_event_list = init_event_list,
evt_react_list = evt_react_list,
util_ongoing_list = util_ongoing_list,
util_instant_list = util_instant_list,
cost_ongoing_list = cost_ongoing_list,
cost_instant_list = cost_instant_list,
other_ongoing_list = other_ongoing_list,
npats = 500,
n_sim = 1,
psa_bool = FALSE,
ipd = 1)
}
}
