% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_sim.R
\name{run_sim}
\alias{run_sim}
\title{Run the simulation}
\usage{
run_sim(
  arm_list = c("int", "noint"),
  sensitivity_inputs = NULL,
  common_all_inputs = NULL,
  common_pt_inputs = NULL,
  unique_pt_inputs = NULL,
  init_event_list = NULL,
  evt_react_list = evt_react_list,
  util_ongoing_list = NULL,
  util_instant_list = NULL,
  util_cycle_list = NULL,
  cost_ongoing_list = NULL,
  cost_instant_list = NULL,
  cost_cycle_list = NULL,
  other_ongoing_list = NULL,
  other_instant_list = NULL,
  npats = 500,
  n_sim = 1,
  psa_bool = NULL,
  sensitivity_bool = FALSE,
  sensitivity_names = NULL,
  n_sensitivity = 1,
  drc = 0.035,
  drq = 0.035,
  input_out = NULL,
  ipd = 1
)
}
\arguments{
\item{arm_list}{A vector of the names of the interventions evaluated in the simulation}

\item{sensitivity_inputs}{A list of sensitivity inputs that do not change within a sensitivity in a similar fashion to common_all_inputs, etc}

\item{common_all_inputs}{A list of inputs common across patients that do not change within a simulation}

\item{common_pt_inputs}{A list of inputs that change across patients but are not affected by the intervention}

\item{unique_pt_inputs}{A list of inputs that change across each intervention}

\item{init_event_list}{A list of initial events and event times. If no initial events are given, a "Start" event at time 0 is created automatically}

\item{evt_react_list}{A list of event reactions}

\item{util_ongoing_list}{A list of utilities that are accrued at an ongoing basis}

\item{util_instant_list}{A list of utilities that are accrued instantaneously at an event}

\item{util_cycle_list}{A list of utilities that are accrued in cycles}

\item{cost_ongoing_list}{A list of costs that are accrued at an ongoing basis}

\item{cost_instant_list}{A list of costs that are accrued instantaneously at an event}

\item{cost_cycle_list}{A list of costs that are accrued in cycles}

\item{other_ongoing_list}{A list of other data that are accrued at an ongoing basis (discounted using drq)}

\item{other_instant_list}{A list of other data that are accrued instantaneously at an event (discounted using drq)}

\item{npats}{The number of patients to be simulated (it will simulate npats * length(arm_list))}

\item{n_sim}{The number of simulations to run per sensitivity}

\item{psa_bool}{A boolean to determine if PSA should be conducted. If n_sim > 1 and psa_bool = FALSE, the differences between simulations will be due to sampling}

\item{sensitivity_bool}{A boolean to determine if Scenarios/DSA should be conducted.}

\item{sensitivity_names}{A vector of scenario/DSA names that can be used to select the right sensitivity (e.g., c("Scenario_1", "Scenario_2")). The parameter "sens_name_used" is created from it which corresponds to the one being used for each iteration.}

\item{n_sensitivity}{Number of sensitivity analysis (DSA or Scenarios) to run. It will be interacted with sensitivity_names argument if not null (n_sensitivityitivity = n_sensitivity * length(sensitivity_names)). For DSA, it should be as many parameters as there are. For scenario, it should be 1.}

\item{drc}{The discount rate for costs}

\item{drq}{The discount rate for LYs/QALYs}

\item{input_out}{A vector of variables to be returned in the output data frame}

\item{ipd}{Integer taking value 1 for full IPD data returned, and 2 IPD data but aggregating events (returning last value for numeric/character/factor variables. For other objects (e.g., matrices), the IPD will still be returned as the aggregation rule is not clear). Other values mean no IPD data returned (removes non-numerical or length>1 items)}
}
\value{
A list of data frames with the simulation results
}
\description{
Run the simulation
}
\details{
This function is slightly different from \code{run_sim_parallel}.
\code{run_sim_parallel} only runs multiple-core at the simulation level.
\code{run_sim} uses only-single core.
\code{run_sim} can be more efficient if using only one simulation (e.g., deterministic),
while \code{run_sim_parallel} will be more efficient if the number of simulations is >1 (e.g., PSA).

A list of protected objects that should not be used by the user as input names to avoid the risk of overwriting them is as follows:
c("arm", "arm_list", "categories_for_export", "cur_evtlist", "curtime", "evt", "i", "prevtime", "sens", "simulation", "sens_name_used","list_env","uc_lists","npats","ipd").

The engine uses the L'Ecuyer-CMRG for the random number generator
}
\examples{
\dontrun{
run_sim(arm_list=c("int","noint"),
common_all_inputs = common_all_inputs,
common_pt_inputs = common_pt_inputs,
unique_pt_inputs = unique_pt_inputs,
init_event_list = init_event_list,
evt_react_list = evt_react_list,
util_ongoing_list = util_ongoing_list,
util_instant_list = util_instant_list,
cost_ongoing_list = cost_ongoing_list,
cost_instant_list = cost_instant_list,
other_ongoing_list = other_ongoing_list,
npats = 500,
n_sim = 1,
psa_bool = FALSE,
drc = 0.035,
drq = 0.035,
ipd = 1)
}
}
