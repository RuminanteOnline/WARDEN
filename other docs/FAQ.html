<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Javier Sanchez Alvarez">
<meta name="dcterms.date" content="2024-11-25">

<title>RDICE FAQ</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="FAQ_files/libs/clipboard/clipboard.min.js"></script>
<script src="FAQ_files/libs/quarto-html/quarto.js"></script>
<script src="FAQ_files/libs/quarto-html/popper.min.js"></script>
<script src="FAQ_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="FAQ_files/libs/quarto-html/anchor.min.js"></script>
<link href="FAQ_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="FAQ_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="FAQ_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="FAQ_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="FAQ_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#why" id="toc-why" class="nav-link active" data-scroll-target="#why">Why</a></li>
  <li><a href="#differences-with-other-dice-tools" id="toc-differences-with-other-dice-tools" class="nav-link" data-scroll-target="#differences-with-other-dice-tools">Differences with other DICE tools</a>
  <ul class="collapse">
  <li><a href="#time-of-event-vs.-time-to-event" id="toc-time-of-event-vs.-time-to-event" class="nav-link" data-scroll-target="#time-of-event-vs.-time-to-event">Time of event vs.&nbsp;time to event</a></li>
  <li><a href="#parallel-computing" id="toc-parallel-computing" class="nav-link" data-scroll-target="#parallel-computing">Parallel Computing</a></li>
  <li><a href="#events-removedrepeated-in-queue-vs.-events-always-exist-only-once" id="toc-events-removedrepeated-in-queue-vs.-events-always-exist-only-once" class="nav-link" data-scroll-target="#events-removedrepeated-in-queue-vs.-events-always-exist-only-once">Events removed/repeated in queue vs.&nbsp;events always exist only once</a></li>
  <li><a href="#explicitly-declaring-qalys-costs-and-other-discounted-outputs" id="toc-explicitly-declaring-qalys-costs-and-other-discounted-outputs" class="nav-link" data-scroll-target="#explicitly-declaring-qalys-costs-and-other-discounted-outputs">Explicitly declaring QALYs, Costs and Other discounted outputs</a></li>
  <li><a href="#random-seeds-monte-carlo-error-and-probabilistic-dsa" id="toc-random-seeds-monte-carlo-error-and-probabilistic-dsa" class="nav-link" data-scroll-target="#random-seeds-monte-carlo-error-and-probabilistic-dsa">Random Seeds, Monte Carlo Error and Probabilistic DSA</a></li>
  <li><a href="#interpretation-of-luck" id="toc-interpretation-of-luck" class="nav-link" data-scroll-target="#interpretation-of-luck">Interpretation of Luck</a></li>
  <li><a href="#language" id="toc-language" class="nav-link" data-scroll-target="#language">Language</a></li>
  </ul></li>
  <li><a href="#things-to-be-aware-of" id="toc-things-to-be-aware-of" class="nav-link" data-scroll-target="#things-to-be-aware-of">Things to be aware of</a>
  <ul class="collapse">
  <li><a href="#backward-vs-forward-accumulation-of-continuous-outcomes" id="toc-backward-vs-forward-accumulation-of-continuous-outcomes" class="nav-link" data-scroll-target="#backward-vs-forward-accumulation-of-continuous-outcomes">Backward vs Forward Accumulation of Continuous Outcomes</a></li>
  <li><a href="#debugging" id="toc-debugging" class="nav-link" data-scroll-target="#debugging">Debugging</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">RDICE FAQ</h1>
<p class="subtitle lead">Version 1.0. Made for RDICE v0.97</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Javier Sanchez Alvarez </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 25, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="why" class="level1">
<h1>Why</h1>
<p>This was created as the R DICE was designed independently from DICE, as well as to be run with R in mind, and not as an interpret of Excel instructions. As such, there are differences in the current version of RDICE relative to oher internally available DICE tools.</p>
</section>
<section id="differences-with-other-dice-tools" class="level1">
<h1>Differences with other DICE tools</h1>
<section id="time-of-event-vs.-time-to-event" class="level3">
<h3 class="anchored" data-anchor-id="time-of-event-vs.-time-to-event">Time of event vs.&nbsp;time to event</h3>
<p>RDICE time is considered from start. This means that when a new event is generated at a given event, the elapsed time from start should be added (<em>curtime</em>). For example, if at time 1.5 a new event is created which takes place one year from now, then that new event will be defined as <code>modify_event(list(new_evt_name = curtime + 1))</code>.</p>
</section>
<section id="parallel-computing" class="level3">
<h3 class="anchored" data-anchor-id="parallel-computing">Parallel Computing</h3>
<p>DICE (at least PyDICE) applies parallelization at the patient level, i.e., splitting patients across threads. Instead, RDICE can use parallelization when running multiple simulations (i.e., in a PSA). The reason for this is that in R it’s more efficient to split the tasks across the different threads when they take some time to run, and each patient may take too little time to take full advantage of this process. However, note that the parallelization in R is limited by the RAM available, so depending on the size of the simulation the benefits in terms of run speed can be more limited.</p>
</section>
<section id="events-removedrepeated-in-queue-vs.-events-always-exist-only-once" class="level3">
<h3 class="anchored" data-anchor-id="events-removedrepeated-in-queue-vs.-events-always-exist-only-once">Events removed/repeated in queue vs.&nbsp;events always exist only once</h3>
<p>In RDICE, the engine does not constrain the event queue to contain the full event list. Instead, the event queue could contain fewer events than the full event list, or more (in the case of repeated events). Events are removed from the queue as they are processed. The user can always set a new event so that there is always a full list of events in the queue.</p>
</section>
<section id="explicitly-declaring-qalys-costs-and-other-discounted-outputs" class="level3">
<h3 class="anchored" data-anchor-id="explicitly-declaring-qalys-costs-and-other-discounted-outputs">Explicitly declaring QALYs, Costs and Other discounted outputs</h3>
<p>RDICE will compute automatically total LYs, total QALYs and total costs, both discounted and undiscounted. Total QALYs and total costs are computed by adding up the items identified as QALYs (for QALYs) and costs (for costs). Other outputs that need to be discounted (continuously or instantaneous) must be explicitly declared as such but will not be aggregated together.</p>
</section>
<section id="random-seeds-monte-carlo-error-and-probabilistic-dsa" class="level3">
<h3 class="anchored" data-anchor-id="random-seeds-monte-carlo-error-and-probabilistic-dsa">Random Seeds, Monte Carlo Error and Probabilistic DSA</h3>
<p>All the DICE tools use a specific set of random seeds to ensure outcomes are replicable across the different engines (ROLL, EviDICE, pyDICE). The starting seed set in DICE is a L’Ecuyer seed set as value 123456 (6 times) in each simulation. RDICE uses a L’Ecuyer seed, but does not force the starting seed to be the same value as in DICE. There are a few reasons for that:</p>
<p>1) DICE does not include Monte Carlo Sampling Error. This means that if one runs a PSA with no parametric uncertainty, no sampling uncertainty would be included (all the simulations would give the same value). RDICE does include this type of uncertainty, which requires the starting seed to change at each simulation. Values will be replicable over runs, as at each simulation i the seed is always set to a specific value.</p>
<p>2) RDICE allows to run probabilistic DSA analysis. This means that a seed must be set also for the potential structural parameters that change only on different iterations of the DSA.</p>
<p>3) RDICE has two type of engines: a parallel engine, and a single core engine. While handling of the seed is straightforward in a single core engine, it’s harder to control explicitly in a parallel engine.</p>
</section>
<section id="interpretation-of-luck" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-of-luck">Interpretation of Luck</h3>
<p>In DICE, luck is interpreted as the “lack of luck”, i.e., a high value (e.g., 0.99) implies an almost immediate time to event, while RDICE is aligned with the R way of interpreting “luck”, so high luck would imply long time to events.</p>
</section>
<section id="language" class="level3">
<h3 class="anchored" data-anchor-id="language">Language</h3>
<p>DICE uses its own type of pseudolanguage, which can differ from what RDICE uses. The process in RDICE is always “set inputs in their correct loading order (sensitivity, simulation, common for all arms, specific patient-arm), set reactions to events, set initial time to events, determine type of outcomes, and execute main function”. Please make sure to review the existing examples and function documentation to understand how to use these functions.</p>
</section>
</section>
<section id="things-to-be-aware-of" class="level1">
<h1>Things to be aware of</h1>
<section id="backward-vs-forward-accumulation-of-continuous-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="backward-vs-forward-accumulation-of-continuous-outcomes">Backward vs Forward Accumulation of Continuous Outcomes</h3>
<p>Continuous outcomes in DICE at Evidera follow a “backward” approach to their accumulation, i.e., the value set for a continuous outcome at event X is applied backwards until the last previous time that outcome was updated. For example, if the previous time it was updated was time 2, and now we update it at time 5, it will apply the value set at time 5 between 2 and 5. RDICE allows for an alternative approach to be implemented, in which the value set at event X is applied forward until the next event. This implies a more “intuitive” approach to how outcomes are implemented, as they work in the same way as any other conditions.</p>
<p>The change in terms of implementations means that if o_q is the accumulator, which is o_q = utility, and utility value changes at event X, in the backward approach one would set 1) o_q = utility (previous value of utility), and then 2) utility = new_value. Instead, in the forward approach one would set 1) utility = new_value, 2) o_q = utility (reversing the order).</p>
<p>This option can be modified in the <code>run_sim</code> and <code>run_sim_parallel</code> functions.</p>
</section>
<section id="debugging" class="level3">
<h3 class="anchored" data-anchor-id="debugging">Debugging</h3>
<p>Log files are created both in RDICE and DICE, but the details included are different. Furthermore, R has a debug method which would allow the user to navigate live through the code at the moment of error. A log file will be created if debug option is activated.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>